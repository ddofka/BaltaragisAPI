# Internationalization (i18n) System

## Overview

The Baltaragis API implements a comprehensive internationalization system that serves Lithuanian (LT) in Lithuania and English (EN) elsewhere, with an interface to manage translations for UI labels and messages.

## Locale Resolution

### Priority Order

The system resolves the appropriate locale using the following priority order:

1. **Explicit Override** - Highest priority
   - `X-Locale` header
   - `locale` query parameter

2. **Accept-Language Header** - Medium priority
   - Parses `Accept-Language` header
   - Supports `lt`, `lt-*`, `en`, `en-*` formats

3. **IP Country Default** - Lowest priority
   - `CF-IPCountry` header (Cloudflare)
   - `X-Country` header (development/testing)
   - Lithuania (LT) → `lt-LT`
   - All other countries → `en-US`

### Examples

```bash
# Explicit override via header
curl -H "X-Locale: lt-LT" /api/v1/i18n/current

# Explicit override via query parameter
curl "/api/v1/i18n/current?locale=lt-LT"

# Accept-Language header
curl -H "Accept-Language: lt,en;q=0.9" /api/v1/i18n/current

# IP country detection (Cloudflare)
curl -H "CF-IPCountry: LT" /api/v1/i18n/current

# Development/testing with X-Country header
curl -H "X-Country: LT" /api/v1/i18n/current
```

## Supported Locales

- **`en-US`** - English (United States) - Default
- **`lt-LT`** - Lithuanian (Lithuania)

## API Endpoints

### Public Endpoints

#### Get Translations for Locale
```
GET /api/v1/i18n/{locale}
```

Returns a flat key-value map of all translations for the specified locale.

**Response Example:**
```json
{
  "common.add_to_cart": "Add to Cart",
  "common.loading": "Loading...",
  "common.error": "Error",
  "common.success": "Success"
}
```

#### Get Current Locale
```
GET /api/v1/i18n/current
```

Returns the resolved locale for the current request.

**Response Example:**
```
"en-US"
```

#### Get Supported Locales
```
GET /api/v1/i18n/locales
```

Returns all locales that have translations.

**Response Example:**
```json
["en-US", "lt-LT"]
```

### Admin Endpoints

#### Create/Update Translation
```
POST /api/v1/admin/translations
```

Creates a new translation or updates an existing one.

**Request Body:**
```json
{
  "key": "common.add_to_cart",
  "locale": "en-US",
  "value": "Add to Cart"
}
```

#### Get Translations by Locale
```
GET /api/v1/admin/translations/locale/{locale}
```

Returns all translations for a specific locale.

#### Get Translations by Key
```
GET /api/v1/admin/translations/key/{key}
```

Returns all translations for a specific key across all locales.

#### Delete Translation
```
DELETE /api/v1/admin/translations/{key}/{locale}
```

Deletes a specific translation.

#### Bulk Upsert Translations
```
POST /api/v1/admin/translations/bulk
```

Creates or updates multiple translations in a single request.

**Request Body:**
```json
{
  "translations": {
    "en-US": {
      "common.add_to_cart": "Add to Cart",
      "common.loading": "Loading..."
    },
    "lt-LT": {
      "common.add_to_cart": "Pridėti į krepšelį",
      "common.loading": "Kraunama..."
    }
  }
}
```

## Database Schema

### Translation Table

```sql
CREATE TABLE translation (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    translation_key VARCHAR(255) NOT NULL,
    locale VARCHAR(10) NOT NULL,
    value TEXT NOT NULL,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_translation_key_locale (translation_key, locale),
    INDEX idx_translation_locale (locale)
);
```

### Initial Data

The system comes pre-populated with common UI translations:

- **English**: Add to Cart, Loading..., Error, Success, etc.
- **Lithuanian**: Pridėti į krepšelį, Kraunama..., Klaida, Sėkmingai, etc.

## Frontend Integration

### Loading Translations

```javascript
// Get current locale
const currentLocale = await fetch('/api/v1/i18n/current').then(r => r.text());

// Load all translations for the locale
const translations = await fetch(`/api/v1/i18n/${currentLocale}`).then(r => r.json());

// Use translations
const addToCartText = translations['common.add_to_cart'];
```

### Persisting User Preference

```javascript
// User selects Lithuanian
localStorage.setItem('preferredLocale', 'lt-LT');

// Send with requests
fetch('/api/v1/i18n/current', {
  headers: {
    'X-Locale': localStorage.getItem('preferredLocale')
  }
});
```

### Fallback Strategy

```javascript
function getTranslation(key, translations) {
  return translations[key] || key; // Fallback to key if not found
}
```

## Content vs. UI Translations

### Content Language
- **Product descriptions** remain in the original content language
- **Page content** is not translated via this system
- **Artist bio** stays in the original language

### UI Translations
- **Button labels** (Add to Cart, Save, Delete)
- **Status messages** (Loading..., Error, Success)
- **Navigation elements** (Back, Next, Previous)
- **Form labels** (Search, Filter, Sort)

## Error Handling

### Validation Errors (400)
- Unsupported locale
- Missing required fields
- Invalid locale format

### Fallback Behavior
- Missing translations fallback to the key
- Unsupported locales throw validation errors
- Network errors fallback to default locale

## Development and Testing

### Testing Locale Resolution

```bash
# Test Lithuanian IP country
curl -H "X-Country: LT" /api/v1/i18n/current

# Test explicit override
curl -H "X-Locale: lt-LT" /api/v1/i18n/current

# Test Accept-Language
curl -H "Accept-Language: lt,en;q=0.9" /api/v1/i18n/current
```

### Adding New Translations

```bash
# Add single translation
curl -X POST /api/v1/admin/translations \
  -H "Authorization: Basic YWRtaW46YWRtaW4xMjM=" \
  -H "Content-Type: application/json" \
  -d '{
    "key": "common.new_feature",
    "locale": "en-US",
    "value": "New Feature"
  }'

# Bulk import
curl -X POST /api/v1/admin/translations/bulk \
  -H "Authorization: Basic YWRtaW46YWRtaW4xMjM=" \
  -H "Content-Type: application/json" \
  -d '{
    "translations": {
      "en-US": {"common.new_feature": "New Feature"},
      "lt-LT": {"common.new_feature": "Nauja funkcija"}
    }
  }'
```

## Performance Considerations

### Caching
- Frontend should cache translations locally
- Consider HTTP caching headers for translation endpoints
- Database queries are optimized with proper indexes

### Scalability
- Translation data is lightweight
- Bulk operations support efficient batch updates
- Locale resolution is stateless and fast

## Future Enhancements

### Planned Features
- **Translation Versioning** - Track changes over time
- **Translation Comments** - Context for translators
- **Import/Export** - CSV, JSON, XLIFF formats
- **Translation Memory** - Suggest similar translations
- **Machine Translation** - Auto-translate missing keys

### Additional Locales
- **Russian (ru-RU)** - For Baltic region
- **Polish (pl-PL)** - For neighboring countries
- **German (de-DE)** - For European market

## Security Considerations

### Access Control
- Public endpoints: Read-only access to translations
- Admin endpoints: Basic authentication required
- No sensitive data in translations

### Input Validation
- Locale codes are strictly validated
- Translation keys have length limits
- Values are sanitized but not HTML-encoded

## Monitoring and Logging

### Metrics to Track
- Locale resolution frequency
- Translation cache hit rates
- Admin operation volumes
- Error rates by locale

### Logging
- Locale resolution decisions
- Translation lookup failures
- Admin operation audit trail
- Performance metrics
